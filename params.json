{"name":"PCAP Parser","tagline":"Parse PCAP files and visualize network data ","body":"## An Open-Source R Package to Parse through Packet Capture Files and Display Graphs \r\nUse Wireshark or another packet sniffing utility to capture IP traffic data, and use PCAP Parser to analyze traffic. \r\n\r\n## How it Works \r\nPacket Capture Files in the libpcap format store data in this order: \r\n    \r\n<Global Header::Packet Header::Packet Data::Packet Header::Packet Data ...>\r\n\r\nPCAP Parser follows this format to gather relevant information about where data originates from and where it goes. This information is provided in the packet capture file in the IPv4 Header. \r\n\r\n```c\r\nstruct ipv4_hdr_s {\r\n\tuint8 vers_hdrlen;\r\n\tuint8 dscp_ecn;\r\n\tuint16 total_len;         /* NETWORK ORDER */\r\n\tuint16 identification;         /* NETWORK ORDER */\r\n\tuint16 flags_frag_ofs;        /* NETWORK ORDER */\r\n\tuint8 ttl;\r\n\tuint8 proto; \r\n\tuint16 hdr_checksum;         /* NETWORK ORDER */\r\n\tuint32 src_ip;         /* NETWORK ORDER */\r\n\tuint32 dst_ip;         /* NETWORK ORDER */\r\n};\r\n```\r\n\r\nThe \"Proto\" flag describes the protocol (TCP/UDP/ICMP) of the packet. Based on this, the following data in the packet is copied to a TCP/UDP/ICMP header structure, using the copy_bytes function: \r\n\r\n```c\r\nvoid copy_bytes (void *_from, void *_to, int num)\r\n{\r\n\tint i;\r\n\tuint8 *from = (uint8 *)_from;\r\n\tuint8 *to = (uint8 *)_to;\r\n\t\r\n\tfor (i = 0; i < num; i++) {\r\n\t\tto[i] = from[i];\r\n\t}\r\n#if 0\r\n\twhile (i < num) \r\n\t\t*to = *from;\r\n\t\tto = to + 1;\r\n\t\tfrom = from + 1;\r\n\ti++;\r\n#endif\r\n}\r\n```\r\n\r\nThe structure of the TCP Header is as follows: \r\n\r\n```c\r\nstruct tcp_hdr_s {\r\n\tuint16 src_port;        /* NETWORK ORDER */\r\n\tuint16 dst_port;         /* NETWORK ORDER */\r\n\tuint32 seq_num;         /* NETWORK ORDER */\r\n\tuint32 ack_num;        /* NETWORK ORDER */\r\n\tuint16 ofs_ctrl;        /* NETWORK ORDER */        \r\n\tuint16 window_size;         /* NETWORK ORDER */\r\n\tuint16 checksum;         /* NETWORK ORDER */\r\n\tuint16 urgent_pointer;         /* NETWORK ORDER */\r\n};\r\n```\r\n\r\nTCP Packets exchanged (syn, syn+ack...fin) between two machines are tracked by a linked list of Flows. The Linked List structure: \r\n\r\n```c\r\nstruct flow_s {\r\n\tuint32 flow_id;\r\n\tuint32 src_ip; \r\n\tuint32 dst_ip; \r\n\tuint16 src_port; \r\n\tuint16 dst_port; \r\n\tuint32 num_pkts;\r\n\tuint32 seq_num; \r\n\tuint8 is_open;\r\n\tuint32 num_bytes1; /* from initiator */\r\n\tuint32 num_bytes2; /* from responder */\r\n\tuint32 start_time; /* first syn */\r\n\tuint32 end_time; /* fin_ack or ack */\r\n\tuint8 closed; \r\n\tuint32 num_init_pkts;\r\n\tuint32 num_resp_pkts;\r\n\tuint32 src_timestamps [MAX_NUM_PACKETS]; /* timestamps on pkts from initiator i.e. who sent first syn */\r\n\tuint32 dst_timestamps [MAX_NUM_PACKETS]; /* timestamps on pkts from responder */\r\n\tuint32 src_seq_nums [MAX_NUM_PACKETS];\r\n\tuint32 src_ack_nums [MAX_NUM_PACKETS];\r\n\tuint32 dst_seq_nums [MAX_NUM_PACKETS];\r\n\tuint32 dst_ack_nums [MAX_NUM_PACKETS];\r\n\tuint32 packets [MAX_NUM_PACKETS];\r\n\tstruct flow_s *next;\r\n};\r\n``` \r\n\r\nEach flow is closed after the fin packet is sent. This way, a linked list of flows is assembled for the R module to visualize. \r\n\r\n### Network Order \r\nRead about Endianness [here](http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html)  \r\n\r\nCertain values in the IP Header code are commented \"Network Order\". These values are stored in Big-Endian format, and thus need to be converted to Little-Endian format, which is how multi-byte values are stored on Intel x86 systems. This is done for integers with the following function: \r\n\r\n```c\r\nunsigned int _int_switcher(unsigned int *x)\r\n{\r\n    char *b1;\r\n    char temp;\r\n\r\n    b1 = (char *) x;\r\n    temp = *b1;\r\n    *b1 = *(b1+3);\r\n    *(b1+3) = temp;\r\n\r\n    temp = *(b1+1);\r\n    *(b1+1) = *(b1+2);\r\n    *(b1+2) = temp;\r\n    return (*x);\r\n}\r\n```\r\n\r\n### Definitions \r\n```c\r\ntypedef unsigned int uint32;\r\ntypedef unsigned short uint16;\r\ntypedef signed int int32;\r\ntypedef unsigned char uint8;\r\ntypedef unsigned char mac_addr_t [6]; \r\n```\r\n\r\n##Visualization \r\n\r\nThe R visualization package is still in progress. To maximize readability, the [ArcDiagrams R Package](http://www.r-bloggers.com/arc-diagrams-in-r-les-miserables/) will be used to visualize various flows. The data is exchanged between the R program and parser is done through function calls of C from the R package. For example, this function creates a flow table: \r\n\r\n```r\r\nget_flow_table <- function () {\r\n\tsrc_ips <- .Call(\"get_src_ipaddr_vector\")\r\n\tdst_ips <- .Call(\"get_dst_ipaddr_vector\")\r\n\tsrc_ports <- .Call(\"get_src_port_vector\")\r\n\tdst_ports <- .Call(\"get_dst_port_vector\")\r\n\tstart_time <- .Call(\"get_start_time_vector\")\r\n\tflow_id <- .Call(\"get_flow_id_vector\")\r\n\r\n\tflow_table <- data.frame (SrcIP = src_ips, DstIP = dst_ips, SrcPort = src_ports, DstPorts = dst_ports, \r\n                                    StartTime = start_time, FlowId = flow_id)\r\n\treturn(flow_table)\r\n}\r\n``` \r\n\r\n##In Progress\r\n\r\n* GeoIP Support: Based on the IP Address, the parser will assemble a table of locations. The goal of this is to show connections on a world map. \r\n* Company Identification Based on MAC Addr. \r\n* Visualization \r\n* IPv6, UDP, ICMP Support \r\n ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}